/*
	在查找过程中我们寻找某个树的根时，由于每一个节点都是指向他的父节点所以会出现单一链条的情况，在寻找后一个节点的根时，一般都需要遍历
	整条线这就导致了时间的增加，正因为如此我们可以想到当我们没有找到根时我们可以将它的父节点指向他前一个元素的父节点，改变元素之间的链
	接状态，减少树的层数，这样就减少了，寻找所需要的时间。
*/

int find ( int p){
	assert( p > 0 && p <= count );
	while( p != parent[p] ){
		parent[p] = parent[parent[p]];
		p = parent[p];
	}
	return p;
}

 
 /*
 	当然还有另外一种方法实现路径的压缩，我们能不能将所有的节点的父节点都指向同一个根节点呢。答案是可以的。
 	所以利用递归的方法我们不断的寻找元素的父节点，最终找到元素的根节点结束递归
 */

 int find( int p ){
  	if( p != parent[p] )
  		parent[p] = find ( parent[p] );
  	//返回的是元素的父节点指向的元素，因为我们利用递归不断的改变元素父节点所指向的位置，最终找到根元素，
  	return parent[p];	
 }



关于并查集的操作当中，时间复杂度近乎是O(1).